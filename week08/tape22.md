

분산 시스템에서 순서를 유지하기 위해서는 일관성이 보장되어야한다.
단일 파티션 트랜잭션의 경우에는 비관적/낙관적 동시성 제어 방식을 기반으로 수행하나, 파티션이 여러개인 트랜잭션의 경우는 다양한 고려가 필요하다.

예를 들어 계좌 이체를 하는 상황을 생각해보자. 한 쪽에서는 출금이 이루어지고, 한 쪽에서는 입금이 이루어져야하며 이 작업은 동시에 수행되어야한다. 하지만 출금과 입금이라는 작업은 원자적이지 않다.

>  출금 : 잔고를 조회하고 금액만큼 차감한 다음 결과를 저장한다.

이러한 여러 작업들을 출금이라는 하나의 단위로 묶어서 수행하는 것을 트랜잭션이라고 한다.
트랜잭션의 원자성은 해당 작업이 모두 수행되거나, 혹은 모두 실패해야한다. 또한 실패가 되는 경우 이전 상태로 복구할 수 있어야하며, 네트워크 파티션이나 노드 장애 상황 속에서도 복구가 가능해야한다.


# 원자적 연산처럼 수행하기

- 원자적 커밋 : 하나의 노드라도 허용하지 않으면 트랜잭션을 커밋할 수 없음.
    - 노드는 트랜잭션 수행 여부에 대한 의견을 나타내고, 원자적 커밋은 이 수행여부에 대한 합의를 도출하기 위해 사용된다.

MySQL, 카프카에서 사용

# 2단계 커밋 (2PC)

준비 단계와 커밋 단계가 나누어져 있으며, 여러 노드가 커밋되거나 abort 되는 두 가지 상태가 있다.

[![Two Phase commit 이란? (2PC)](https://velog.velcdn.com/images/jungbumwoo/post/5c0085b8-8a8b-4c44-ae9d-2d61c9d34f71/image.png)

- 준비 : 코디네이터 노드가 코호트(나머지 노드)에 새 트랜잭션 요청을 알리면, 각 노드들은 커밋 여부를 결정한다.
    - 코디네이터, 다른 노드 모두 응답을 로그에 기록한다.
        - 어디에다 저장하지? =>

- 커밋 : 모든 노드가 트랜잭션에 동의하면 커밋을 진행하고, 한 노드라도 거절한다면 해당 트랜잭션은 abort 된다.


### 코호트가 장애나는 경우

하나의 코호트가 장애나는 경우 모든 노드가 동의할 수 없는 상태이기 때문에 코디네이터는 커밋할 수 없어 트랜잭션을 중단한다.

만약 준비단계가 지나서 코디네이터가 커밋을 결정한 이후에 노드에서 장애가 발생하는 경우는, 장애가 복구될때까지 코디네이터가 지속적으로 재시도를 한다.

### 코디네이터가 장애나는 경우

-  커밋 단계에서 코디네이터 장애가 나는 경우, 코호트는 결과를 전달받지 못하기 때문에 인근 노드의 로그나 백업 코디네이터로부터 결과를 직접 확인한다.
- 코디네이터가 의사결정을 하고 나서  장애가 발생하는 경우는, 코디네이터가 어떤 결정을 했는지 알 수 없기 때문에 불확실한 상태에 빠진다.
    - blocking 원자적 커밋 알고리즘 ?


** 보상 트랜잭션


# 3단계 커밋

코디네이터 장애 발생 시 시스템 상태에 따라 코흐트가 직접 결정을 할 수 있는 단계를 추가하고, timeout을 둔다.이 프로토콜은 아래와 같이 가정하고 있다.

- 요청이 동기적이며
- 통신 장애는 발생할 수 없다.

코디네이터 장애가 발생해도 동작하도록 제안 단계가 추가되고, 시간이 초과되면 강제로 트랜잭션을 커밋하거나 중단하는 timeout 시간이 있다.

- 제안: 코디네이터는 코호트에 제안 값을 전달하고 의견을 수집한다.
- 준비 : 의견을 수렴해서 코호트에  prepare이나 abort 를 전달한다.
- 커밋: 코디네이터가 트랜잭션 커밋을 지원한다.


하지만 기약없는 지연이 있는 네트워크에서 timeout은 신뢰성 있는 장애 감지기가 아니다. 실제 장애는 아니지만 요청이 타임아웃되어서 중단될 수 있기 때문이다.


# 분산 트랜잭션 처리


## 칼빈

fast distributed transaction ?

복제 노드 간에 실행 순서와 트랜잭션 범위를 미리 결정하면 코디네이터 필요 없이 인풋/아웃풋을 동일하게 가져간다.

- 모든 트랜잭션 진입점 역할을 하는 시퀀서로 순서를 보장
- 타임라인을 epoch로 분할해서, 10ms 별로 트랜잭션을 수집해서 그룹화
- 시퀀서가 순서를 결정하면, 스케줄러에 전달해서 트랜잭션 일부를 병렬로 수행
    - 트랜잭션이 명시한 부분만 상태가 변하고, 실행순서도 정해져있어서 노드랑 시퀀서가 통신할 필요 X


시퀀서, 스케줄러, 워커, 스토리지는 같은 노드에 배치되며, 팍소스 합의 알고리즘이나 비동기 복제 노드 방식을 사용해서 시퀀서 사이의 어떤 트랜잭션을 현재 에포크/배치에 추가할지 합의한다.

> 팍소스 합의 : 분산되어있는 각 노드들이 동일한 작업내용을 같은 순서로 실행하게끔 하는 알고리즘.
> https://github.com/Bookstore3/Paxos-Algorithm-Lecture/blob/master/ch01-paxos.md#팍소스-알고리즘의-failure-model

> 비동기 복제 노드



# 스패너

각 파티션 합의 그룹별로 2PC 프로토콜을 사용해 트랜잭션을 처리한다. (칼빈은 시퀀서 사이의 합의)

- TrueTime: 일관성과 트랜잭션 실행순서를 보장하기 위해 정밀한 실제 시간을 제공하는 API
- 읽기-쓰기 트랜잭션 : 잠금/ 비관적 동시성 제어를 사용하며 리더 노드가 필요
- 읽기 전용 트랜잭션 : 잠금 없이 모든 복제노드에서 실행
    - https://cloud.google.com/spanner/docs/transactions?hl=ko
    - 과거 타임스탬프의 값들을 읽어와서 잠금이나 커밋이 필요없다.
- 스냅숏 읽기 : 모든 값을 버전화하고 스냅숏 내용은 수정되지 않으므로 특정 타임스탬프의 일관성이 보장된다.

쓰기는 팍소스 그룹 리더를 거치고, 읽기 요청은 최신 상태의 복제노드와 태블릿이 처리한다.



# 데이터베이스 파티셔닝

가장 단순한 파티셔닝은 데이터를 여러 범위로 분할하고 복제노드 세트에 특정범위만 저장하는 것이다.

- 샤딩은 복제노드 세트 별로 데이터의 특정 범위를 저장하는 파티셔닝 방식을 말한다.
    - 데이터를 나누어서 다른 서버에 분산해서 저장하는 방식

노드가 추가되거나 제거되면 균형을 유지하기 위해 데이터를 다시 파티셔닝하는데,  클러스터 메타데이터를 업데이트하고 데이터를 재배치한다.

일부 데이터베이스는 라우팅 키의 해시 값을 계산해 노드id와 매핑하는데, 해시 값은 실제 값과 동일하게 정렬되어있지 않아서 특정 범위에 키가 몰리는 현상을 방지한다. 하지만 해싱을 하게 되면 인접한 키임에도 다른 노드에 배치될 수도 있다.


## 일관된 해싱

보통의 해시는 노드 v는 hash(v) % 전체노드개수(N) 으로 구하지만,
이렇게 되면 전체 노드의 수가 추가되거나 제거되는 경우 데이터를 재배치해야하는 문제가 있다.

그래서 해시 값을 링에 매핑해서, 노드 수가 변하면 클러스터 전체가 아니라 인접 노드만 영향을 받는 일관된 해싱 방법을 사용할 수 있다.

k개의 해시 키와 n개의 노드로 구성된 클러스터에서 크기가 변경되면, k/n 개의 키가 재배치된다.
https://youtu.be/1a4iG-SYWMc?si=FuKLdVpBCqVPmP-h


## 퍼콜레이터의 분산 트랜잭션 관리

- 스냅숏 격리로 쓰기 이상 현상을 방지할 수 있다.

<스냅숏이 없다면....>
x+y 100 이라고 가정했을 때,
T1 read x 70
T2는 50,50으로 적고 커밋
T1는 read y 50이어서 결과모순

SI는 트랜잭션이 특정 타임스탬프 전 값만 읽도록 보장하기 때문에 T1은 y가 50인 값을 모른채 진행된다.

- 퍼콜레이터 : 분산 DB에서 트랜잭션 API를 제공하는 라이브러리.
    -  데이터 레코드와, 커밋된 데이터 위치를 저장하고 컬럼 단위의 락을 제공

1) 초기 상태에는 아무런 락 없이 이전 트랜잭션이 종료된 시점의 데이터와 타임스탬프가 있다.
2) preWrite로 수정하려는 모든 셀에 잠금을 요청하고, 하나는 primary 잠금으로 복구 시에 사용한다. 여기서 충돌 발생여부를 확인해서 감지되면 트랜잭션을 중단한다.
3) 모든 잠금을 획득하고, 충돌도 없다면 트랜잭션을 수행한다.
4) primary 잠금부터 해제하고, 잠금을 쓰기 레코드로 대체한다음 마지막 타임스탬프 값을 업데이틑하여 결과를 게시한다.


http://eincs.com/wiki/Percolator/

![[스크린샷 2023-09-28 오후 6.12.04.png]]


** TiDB 는 퍼콜레이터 모델을 채용하고 있는 대표적인 DB
https://www.devkuma.com/docs/tidb/mysql-compatibility/


## 코디네이션 생략

불변인 다른 상태들을 하나의 상태로 병합할 때는 코디네이션을 생략해도 데이터 무결성을 보장할 수 있다.

코디네이션을 생략하면 다음과 같은 속성을 보장해야한다.

- 유효성 : 일치하지 않거나 병합된 데이터베이스 상태는 불변조건을 충족해야한다.
- 가용성 : 노드는 트랜잭션 커밋 여부에 대해 합의해야한다.
- 수렴 : 각 노드는 각자의 상태를 유지하되, 다른 트랜잭션이 없으면 같은 상태로 수렴해야한다.
- 코디네이션 생략 : 로컬 트랜잭션은 다른 노드를 대신해 로컬 상태에 대해 수행한 작업과 독립적이다.
    - RAMP 트랜잭션 








