# 13. 분산 트랜잭션

- 상호 조정과 분산 커밋, 롤백 프로토콜

## 원자적 연산처럼 수행하기
- 커밋은 포인터가 가리키는 위치를 변경해 새로운 데이터에 대한 접근을 허용하는 간단한 작업이다.
- 커밋된 트랜잭션의 결과를 어떻게 최대한 빠르게 접근 가능한 상태로 만들 것인가?
- 실패한 트랜잭션은 어떻게 롤백할 것인가?

- 2단계 커밋: 커밋 문제는 해결할 수 있지만, 코디네이터 프로세스의 장애를 허용하지 않는다.
- 3단계 커밋: 논블로킹 원자적 커밋 문제를 해결하고 코디네이터의 장애를 허용한다.

## 2단계 커밋
- 1 단계 결과를 전파하고 의견을 수립한다.
- 2 간계 1단계의 결과를 접근 가능한 상태로 한다.
- 스패너의 경우 2PC 를 개별 노드가 아닌 팍소스 그룹 단위로 실행해 프로토콜의 가용성을 개선한다.
- 2PC는 수락한 제안은 철회할 수 없으며, 오직 코디네이터만이 트랜잭션을 중단시킬수 있다.
- MySQL, PostgreSQL, MongoDB 등이 이를 사용한다.:
  - MongoDB 에서는 사용했었다. 지금은 사용하지 않음. Write Concern 을 조절해서 모방할수는 있다.

## 3단계 커밋
- 제안: 코디네이터는 코호트에 제안 값을 전달하고 의견을 수집한다.
- 준비: 코디네이터는 코호트에 수렴 결과를 알린다. 모두 커밋에 동의한 경우 Prepare 메시지를 보내 커밋을 준비하도록 지시한다.  반대의 경우 Abort 메시지를 보내고 라운드를 완료한다.
- 커밋: 코디네이터는 코호트에게 트랜잭션 커밋을 지시한다.
- 이론적으로 3PC 프로토콜은 2PC의 블로킹 문제를 해결할 수 있지만 메시지 오버헤드가 더 크고 일관성을 보장하지 않으며, 트깋 네트워크 파티션 발생시 제대로 작동하지 않는다.

## 칼빈의 분산 트랜잭션 처리
- 복제 노드 사이의 실행 순서와 트랜잭션의 범위를 미리 결정하는 방법도 있다.
- FaunaDB
- 대신 읽기를 수행해 쓰기를 하는 읽기 쓰기 세트를 결정하는 트랜잭션은 지원하지 않는다.
- 스케줄러가 제어하는 워크 쓰레드의 단계:
  - 트랜잭션의 읽기와 쓰기 세트를 분석해 읽기 세트에서 로컬 레코드를 찾고 활성화 목록을 작성한다.
  - 트랜잭션을 수행하는 데 필요한 로컬 데이터를 수집한다. 읽기 세트에 포함된 데이터 레코드 중 해당 노드에 저장된 레코드를 의미한다. 수집한 로컬 레코드를 활성 노드에 전달한다.
  - 워커 쓰레드가 활성 노드에서 실행 중인 경우 다른 노드로부터 2단계의 결과를 전달 받는다.
  - 마지막으로 트랜잭션 배치를 수행하고 결과는 로컬 스토리지에 저장한다. 각 노드는 동일한 인풋으로 트랜잭션을 수행하고 로컬에 결과를 저장하기 때문에 결과를 서로 전달하지 않아도 된다.

## 스패너의 분산 트랜잭션 처리
- Spanner, CockroachDB, YugaBytes DB
- TrueTime 을 사용해 일관성과 트랜잭션 실행 순서를 보장한다.
- TrueTime: 실제 시간을 제공하는 API 이며 오차 범위가 존재한다.
- 읽기-쓰기 트랜잭션, 읽기 전용 트랜잭션, 스냅숏 읽기를 지원
- 각 데이터 레코드에는 트랜잭션이 커밋된 시간을 의미하는 타임스탬프를 설정한다.

## 데이터베이스 파티셔닝
- 일부 데이터베이스는 자동 샤딩을 수행한다.

### 일관된 해싱
- 아파치 카산드라와 리악, 일관된 햇싱이라는 파티셔닝 방법을 사용한다.
- 필요한 재배치 횟수를 줄일 수 있다.

## 퍼콜레이터의 분산 트랜잭션 처리
- First commit wins
- Snapshot Isolation:
  - 오직 커밋된 데이터만 반복 읽기를 허용한다.
  - 특정 타임스탬프 시점의 스냅숏을 읽기 때문에 일관성이 보장된다.
  - 일관성 유지를 위해 충돌 발생 시 쓰기를 중단 후 재시도 한다.
- 쓰기 쏠림 현상으로 인해 Snapshot Isolation 을 직렬화 할수 없을 수도 있다.
- 퍼콜레이터: 빅테이블에서 제공하는 API 라이브러리
- 퍼콜레이터 모딜의 대표적인 데이터베이스: TiDB

## 코디네이션 생략
- 유효성: 일치하지 않거나 병합된 데이터베이스 상태는 모두 불변 조건을 충족해야 한다. 트랜잭션은 절대 유효하지 않은 상태를 읽을 수 없다.
- 가용성: 클라이언트가 상태가 저장된 모든 노드에 연결할 수 잇는 경우, 트랜잭션 커밋여부에 대해 합의해야한다. 만약 커밋으로 인해 일부 조건을 위반한다면 트랜잭션을 중단한다.
- 수렴: 각 노드는 각자의 상태를 유지한다. 하지만 다른 트랜잭션이 없거나 무기한 네트워크 파티션이 발생하지 않는 경우 같은 상태로 수렴할 수 있어야 한다.
- 코디네이션 생략: 로컬 트랜잭션은 다른 노드를 대신해 로컬 상태에 대하 수행한 작업과 독립적이다.
- 동기화 독립성: 클라이언트의 트랜잭션은 중지 또는 중단하지 않고 다른 클라이언트의 트랜잭션을 강제로 기다리게 하지 않는다.
- 파티션 독립성: 클라이언트는 트랜잭션에서 사용하지 않느 ㄴ값이 포함된 파티션은 요청하지 않는다.
